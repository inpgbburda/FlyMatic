# Motor Control for Propulsion System

## Overview
This document outlines the control of electric motors that drive the drone's propellers. The motors are controlled using PWM signals, which are modulated to adjust the speed and direction of the propellers.

## Hardware Components
- **Motors:** RCX 1806 2400kV (Clockwise and Counterclockwise)
- **Motor Drivers:** Brushless ESC 20A 2-3S with a built-in BEC 2A

## Controlling Motor Drivers

### PWM Configuration
- **Frequency:** 50 Hz
- **Duty Cycle:** 5% (1ms) to 10% (2ms) (corresponding to minimum and maximum speed)

### Relationship Between PWM and Motor Speed
The PWM signal's duty cycle directly controls the motor speed. A higher duty cycle increases the speed, while a lower duty cycle decreases it.

### Practical Implementation
The PWM signals are generated by the STM32 microcontroller running FreeRTOS. The values are dynamically adjusted based on inputs from the accelerometer and gyroscope data.

## Related Sections
- [RTOS Configuration](rtos.md): For details on task scheduling related to motor control.

## Software solution

### Static Architecture
![alt text](images/MotorCtrlArchitecture.drawio.png)

### Dynamic Architecture
```puml
@startuml
title CalculateMotorsSets()

participant "RTOS"       as RTOS
participant "Task_1"     as Task_1
participant "Task_2"     as Task_2
participant "Spi_Hw"     as Spi_Hw
participant "Pwm_Hw"     as Pwm_Hw
queue       "RTOS_Queue" as P1

RTOS -> Task_1 : StartTask_1
activate Task_1

Task_1 ->> P1 : SetNewValues()
activate P1

P1 -->> Task_1 :
deactivate P1

Task_1 ->> Spi_Hw : SpiReadIt()
activate Spi_Hw 

Spi_Hw -->> Task_1 :
deactivate Spi_Hw
deactivate Task_1

loop infinite
Task_2 ->> P1 : GetLastValues()
activate Task_2
activate P1

P1 -->> Task_2 : 
deactivate P1

Task_2 ->> Pwm_Hw : UpdatePwm()
activate Pwm_Hw

Pwm_Hw -->> Task_2 :
deactivate Pwm_Hw
deactivate Task_2

Spi_Hw -> Task_1 : MessRxCompleted()
activate Task_1

Task_1 ->> P1 : SetNewValues()
activate P1

P1 -->> Task_1 :
deactivate P1

Task_1 ->> Spi_Hw : SpiReadIt()
activate Spi_Hw 

Spi_Hw -->> Task_1 :
deactivate Spi_Hw
deactivate Task_1
end
@enduml
```

### Detailed Design
```puml
@startuml

scale 2
title MotorCtrlExecutePeriodic()

start
:Get latest power requests;
if (item succesfully rceived from queue?) is (yes) then
repeat
:Calculate new PWM values;
:Apply new PWM values;
backward: motor++;
repeat while (motor<MOTORS_NUMBER?) is (yes) not (no)
else (no)

endif
stop

@enduml
```