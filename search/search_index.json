{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FlyMatic Project Documentation Index","text":""},{"location":"#overview","title":"Overview","text":"<p>FlyMatic is an drone project that integrates both software and hardware components to enable device to fly. This documentation provides detailed information on the repositories, project architecture and key functionalities.</p>"},{"location":"#prototypes-revisions","title":"Prototypes revisions","text":""},{"location":"#proto-1","title":"Proto 1","text":"<p>Pendulum with 2 motors, self balancing. </p>"},{"location":"#proto-2","title":"Proto 2","text":"<p>Chassis with 4 proppellers, self stabilizing. To be done in further steps. </p>"},{"location":"#software-repositories","title":"Software Repositories","text":"<ul> <li>STM32 Firmware Repository: Contains the firmware for the STM32F4 microcontroller, including FreeRTOS and motor control logic.</li> <li>Raspberry Pi Software Repository: Contains the real-time Linux code for sensor data processing and communication.</li> </ul>"},{"location":"#hardware-repositories","title":"Hardware Repositories  +","text":"<ul> <li>EE KiCad Project Repository: Contains schematics of electrical conntections.  </li> </ul> <p>Download - FlyMaticEE.pdf </p>"},{"location":"#project-architecture","title":"Project Architecture","text":"<pre><code>    graph TD\n\n    A[ MainUnit\n    Raspberry pi\n    Real Time Linux/ C++] &lt;--&gt; |I2C| B[Accelleration sensor]\n    A --&gt; |Spi| C[AuxUnit\n    Stm32F4 \n    FreeRTOS/C]\n    C --&gt; |Pwm| D[Electric motors]</code></pre>"},{"location":"software-design/aux_unit-motor_control/","title":"Motor Control for Propulsion System","text":""},{"location":"software-design/aux_unit-motor_control/#related-sections","title":"Related Sections","text":"<ul> <li>AuxUnit - RTOS Configuration: For details on task scheduling related to motor control.</li> </ul>"},{"location":"software-design/aux_unit-motor_control/#software-solution","title":"Software solution","text":""},{"location":"software-design/aux_unit-motor_control/#static-architecture","title":"Static Architecture","text":""},{"location":"software-design/aux_unit-motor_control/#dynamic-architecture","title":"Dynamic Architecture","text":"<pre>0742b7b3087c7508f426fec1c90a7e84aa7348f1886dfcca018c1dac1041d23fab9c47d35e50256a0da204c5dea2a1ebcc28e5d48b76dff40cdbdb153b9c50ea</pre><pre>9e2dca0bbc36f61882299f83e9bd84c6ab879d57d5ccbe7a449c659faee7372da9d92c37aa7a766770c8c4045f7ca6bbca630e3a650fff0afccc9a7b1cf763e7</pre>"},{"location":"software-design/aux_unit-motor_control/#detailed-design","title":"Detailed Design","text":"<pre>78c4daff91dbc2bf19aba303907ceb9ffdd4e6ee8e2dba5e9e1bb6dc9521d9858a6aabd2aca194ff411c656d03c7de467893a5ec49f3c576c820788cbe0ac6fc</pre><pre>2e5439c6f01a42c9ee151a4c1dc29840b0717efa7db74368b69eea7b76c39c622b589625ce9436b9b976e55df45070d0ecf35b5e55a8c8967916313fb3d50edb</pre> <pre>09789e30e9c6640c01312e938aad682c79502fb4afaaf69ae5f57627df2b23f1fb696f80ff061af2bf91be05f2101630cea566b86ccf4fb1e550d0ea45f5deab</pre><pre>253f4e61997553aaca167994036db632053af00e589e6c086ac9a5799d4b650030c85f4e5615ce53fc9356ebeac6afaad4df92a350e55c81001ea624c79f5712</pre> <pre>90de9fa5db11d7a9912fbe75d6b1b51aa786a3ddb55fb4fe54b89fec7404ff2b473848bb7022fdcd0c48bb55a68ba6df4b6c5b4bbed062727ed86759ab9dcd99</pre><pre>12d78812cf2ec24e3b5db77b86226f235acae64a26c6626e6edc10d5abe8975440a8ccafebb4921d042b9aa51e64c260959a1d3be2bcb4d7e58d50965b6a42c9</pre>"},{"location":"software-design/aux_unit-rtos/","title":"AuxUnit - RTOS Configuration","text":""},{"location":"software-design/aux_unit-rtos/#configured-tasks","title":"Configured Tasks","text":""},{"location":"software-design/aux_unit-rtos/#1-spi-communication-task","title":"1. SPI Communication Task","text":"<ul> <li>Function: Reads SPI messages containing requested PWM values from the Raspberry Pi.</li> <li>Priority: High</li> <li>Execution Frequency: 100 Hz</li> </ul>"},{"location":"software-design/aux_unit-rtos/#2-pwm-output-task","title":"2. PWM Output Task","text":"<ul> <li>Function: Writes PWM signals to the motor driver hardware based on the received SPI messages.</li> <li>Priority: Medium</li> <li>Execution Frequency: 50 Hz</li> </ul>"},{"location":"software-design/aux_unit-rtos/#task-synchronization","title":"Task Synchronization","text":"<p>The tasks are synchronized using FreeRTOS semaphores to ensure that PWM adjustments are made in real-time without data conflicts.</p>"},{"location":"software-design/aux_unit-spi/","title":"Bus settings","text":"<p>Bus details:     - MainUnit is a master of communication.     - Motorola mode     - first edge of SCK as latching event     - low SCK state assummed as idle     - 8 bit format of data frame</p>"},{"location":"software-design/main_unit/","title":"Overview","text":"<p>The MainUnit is a master for all system logic and control. It's deployed on <code>RPI4B</code> board with OS:  </p> <p>System name : - <code>Linux raspberrypi 6.6.31-rt30-v8+ #1 SMP PREEMPT_RT</code> Hardware name: - <code>aarch64</code></p> <p>The OS is patched with <code>PREEMPT_RT</code> - more about here linux_foundation_link. To avoid building kernel from scratch, pre-prepared version was built. GitHub - remusmp/rpi-rt-kernel</p> <p>The most important feature of the <code>PREEMPT_RT</code> patch, is that it that the scheduler can preemt almost every kernel operation.  </p> <p>As a consequence, the user (time critical) threads cam now treated with the higher priority. In most cases, it allows to achieve <code>100us</code> time resolution. More about it: linux_doc_link</p>"},{"location":"software-design/main_unit/#dynamic-architecture","title":"Dynamic Architecture","text":"<pre>294c03b0ab486c3f2b60d4d09804a8592cb7c70a129d10513d660290943c93be7417b81119a5227ce0cc33aa976009f0fef681e9755e836d898f876e52432d2a</pre><pre>00ba1311833e3b5efdef8416d3d79e0785cd089e4428f50d1dd283c823bea793fde4600f65a8b375de090391f92f38e3d37aa5f6be18887bf9b9245ec487ab57</pre> <pre>16f6b38eadb79dc05df4dcfb46013d86b939be38dab1974dca8971f9e204ef06b2dba1edf561a357f9afce7d67f00a73d483a20d9e479477b53d31a0128b63ad</pre><pre>9c1077b62aee4285a10003101ef8ee5dc8f0ae8e8499727e73558447fd9d3d0b7b1b275c3459cb0b2537be28954a7e32566f26c7c28dc0ff14a44d8a595d7e78</pre>"},{"location":"system-design/angle_sensing/","title":"Angle Sensing with MPU-6050 for Spirit Level Application","text":""},{"location":"system-design/angle_sensing/#introduction","title":"Introduction","text":"<p>This document describes the use of the MPU-6050 sensor for angle measurement, particularly in the context of a spirit level application. The MPU-6050 integrates a 3-axis accelerometer and a 3-axis gyroscope, enabling it to accurately measure the orientation of an object.</p>"},{"location":"system-design/angle_sensing/#key-concepts","title":"Key Concepts","text":""},{"location":"system-design/angle_sensing/#mpu-6050-accelerometer-data","title":"MPU-6050 Accelerometer Data","text":"<p>The MPU-6050 provides acceleration data across three axes (X, Y, Z). These values represent the gravitational force acting on each axis, which can be used to determine the tilt angle.</p>"},{"location":"system-design/angle_sensing/#angle-calculation","title":"Angle Calculation","text":"<p>To calculate the tilt angle, we use the acceleration data provided by the MPU-6050. The angle is derived using the <code>arcsin</code> function, which computes the angle from the ratio of the accelerometer readings to the gravitational constant.</p>"},{"location":"system-design/angle_sensing/#formula-for-angle-calculation","title":"Formula for Angle Calculation","text":"<p>The angle \u03b8 can be calculated as follows: $$ [ \\theta = \\arcsin\\left(\\frac{A_x}{\\sqrt{A_x^2 + A_y^2 + A_z^2}}\\right) ] $$ Where: - <code>Ax</code>: Acceleration along the X-axis - <code>Ay</code>: Acceleration along the Y-axis - <code>Az</code>: Acceleration along the Z-axis</p>"},{"location":"system-design/angle_sensing/#practical-application","title":"Practical Application","text":"<p>This angle calculation is crucial for maintaining the balance of the drone and can also be used in applications like a digital spirit level.</p>"},{"location":"system-design/angle_sensing/#related-sections","title":"Related Sections","text":"<ul> <li>Motor Control: To understand how angle data influences motor adjustments.</li> </ul>"},{"location":"system-design/motor_control/","title":"Motor Control for Propulsion System","text":""},{"location":"system-design/motor_control/#overview","title":"Overview","text":"<p>This document outlines the control of electric motors that drive the drone's propellers. The motors are controlled using PWM signals, which are modulated to adjust the speed and direction of the propellers.</p>"},{"location":"system-design/motor_control/#hardware-components","title":"Hardware Components","text":"<ul> <li>Motors: RCX 1806 2400kV (Clockwise and Counterclockwise)</li> <li>Motor Drivers: Brushless ESC 20A 2-3S with a built-in BEC 2A</li> </ul>"},{"location":"system-design/motor_control/#controlling-motor-drivers","title":"Controlling Motor Drivers","text":""},{"location":"system-design/motor_control/#pwm-configuration","title":"PWM Configuration","text":"<ul> <li>Frequency: 50 Hz</li> <li>Duty Cycle: 5% (1ms) to 10% (2ms) (corresponding to minimum and maximum speed)</li> </ul>"},{"location":"system-design/motor_control/#relationship-between-pwm-and-motor-speed","title":"Relationship Between PWM and Motor Speed","text":"<p>The PWM signal's duty cycle directly controls the motor speed. A higher duty cycle increases the speed, while a lower duty cycle decreases it.</p>"},{"location":"system-design/motor_control/#practical-implementation","title":"Practical Implementation","text":"<p>The PWM signals are generated by the STM32 microcontroller running FreeRTOS. The values are dynamically adjusted based on inputs from the accelerometer and gyroscope data.</p>"},{"location":"system-design/ms_communication/","title":"Sending power control from master to slave","text":""},{"location":"system-design/ms_communication/#frame-format","title":"Frame format","text":"<p>Power requests shall be send in the following frame format through the SPI bus:</p> 0 1 2 3 Power_1 Power_2 Power_3 Power_4 <p>Values are in range of <code>uint8</code> format:</p> <p>0 - No power requested on corresponding motor 255 - maximum power requested on corresponding motor</p> <p>Bytes are sent in ascending order (Power_1 to Power_4)</p>"},{"location":"system-design/ms_communication/#period-of-sending","title":"Period of sending","text":"<p>Frames shall be sent from MainUnit to AuxUnit cyclicaly with <code>10ms</code> period. MainUnit shall be a master of communication.</p>"}]}